package Crypt::MultiKey::PKey;
use strict;
use warnings;
use Carp;
use Scalar::Util qw/ blessed /;
use MIME::Base64;
use Digest::SHA qw/ sha256_base64 /;
use Crypt::SecretBuffer qw/ secret span BASE64 ISO8859_1 /;
use Crypt::SecretBuffer::PEM;
use Crypt::MultiKey;

=head1 SYNOPSIS

  # Generate a public/private keypair
  my $key= Crypt::MultiKey::PKey->generate('x25519');
  
  # encrypt the private half with a password
  my $pass= Crypt::SecretBuffer->new;
  $pass->append_console_line(STDIN) or die;
  $key->encrypt_private($pass);
  
  # Throw away the private half
  $key->clear_private;
  
  # encrypt some other data with the public half of the key
  my $enc= $key->encrypt("Example Plaintext");
  say JSON->new->encode($enc); # It's a hashref that you can serialize
  
  # restore the private key, using the password
  $key->decrypt_private($pass); # croaks on wrong pass
  
  # Decrypt the data
  say $key->decrypt($enc); # "Example Plaintext"

=head1 DESCRIPTION

C<Crypt::MultiKey::PKey> is a public/private keypair where the public half is always available,
but the private half can be encrypted or removed.  The PKey can always L</encrypt> data, but the
private half must be avalable to L</decrypt> that data again.

=attribute algorithm

The type of public-key cryptography used.  The default is C<'x25519'>.

=attribute fingerprint

SSH-style C<< "sha256:base64..." >> used to help identify the key.

=attribute path

A disk path from which this key was loaded or to which it will be saved.

=attribute mechanism

The mechanism for decrypting/restoring the private half of the key.  This is used as a class
name suffix for the PKey object and affects the behavior of the PKey object.  Any key with the
L</private_encrypted> attribute can be decrypted using L</decrypt_private>, but this attribute
indicates the I<source> of the password, such as whether it is a human-typed text password, or
a password generated from a YubiKey's hash function, etc.  Keys with the mechanism 'Password'
will interactively prompt the user on the console, where keys with the mechanism 'SSHAgent'
will silently query the SSH agent for whether the required SSH key is available.

=attribute has_public

Boolean; whether this key currently has the public half loaded.  This will be true except when
loaded from a PEM file which only contained an encrypted private key, and the password hasn't yet
been supplied.

=attribute has_private

Boolean; whether this key currently has the private half loaded.  See L</clear_private> and
L</decrypt_private>.

=attribute public

Export the public key in ASN.1 SubjectPublicKeyInfo structure defined in RFC5280, then encode
as Base64.

=attribute private

Export the private key as PKCS#8 (unencrypted) stored in a L<SecretBuffer|Crypt::SecretBuffer>
as raw ASN.1 bytes.  This can be combined with L<Crypt::SecretBuffer::PEM> to produce a standard
OpenSSL PEM text.

=attribute private_encrypted

This attribute may hold any format recognized by the L</import_privkey> method, for delayed
importing via the L</decrypt_private> method.  When this attribute is generated by the
L</encrypt_private> method, it will always be a PKCS#8 ciphertext encoded as BASE64 without the
PEM wrapper.

=cut

sub type { $_[0]{type} }

sub fingerprint {
   $_[0]{fingerprint} ||= do {
      $_[0]->_export_spki(my $pub);
      'SHA256:'.sha256_base64($pub);
   };
}

sub path {
   @_ > 1? $_[0]{path}= $_[1] : $_[0]{path};
}

sub mechanism {
   @_ > 1? $_[0]->_set_mechanism($_[1]) : undef;
}
# mechanism attribute is writable, but may only rebless into a subclass
sub _set_mechanism {
   my ($self_or_class, $mechanism)= @_;
   my $class= ref $self_or_class || $self_or_class;
   my $subclass= Crypt::MultiKey::lazy_load(__PACKAGE__.'::'.$mechanism);
   $subclass eq $class or $subclass->isa($class)
      or croak "Mechanism $subclass does not derive from $class";
   if (ref $self_or_class) {
      return bless $self_or_class, $subclass;
   } else {
      return $subclass;
   }
}

sub public {
   @_ > 1? $_[0]->import_pubkey($_[1])
   : do {
      shift->_export_spki(my $buf);
      encode_base64($buf, '');
   };
}

sub private {
   @_ > 1? $_[0]->import_privkey($_[1])
   : shift->_export_privkey;
}

sub private_encrypted {
   @_ > 1? $_[0]{private_encrypted}= $_[1]
   : $_[0]{private_encrypted}
}

=constructor new

  $key= Crypt::MultiKey::PKey->new(%options);

Construct a new Public/Private Key.  Writable attributes and methods can be supplied as options,
along with C<'password'> in order to immediately attempt unlocking an encrypted private key.

=over

=item mechanism

If mechanism is a known subclass, this invokes the subclass constructor.

=item path

Specify the path attribute, which can be used as a default for L</load> and L</save>.
If none of C<generate>, C<public>, C<private>, or C<private_encrypted> are supplied, and the
path exists, the constructor will call 'import' on that path.
It can also locate a public key C<"$path.pub"> if the C<$path> holds only a private key.

=item generate

Immediately generate a new key of the specified type.  The C<private>, C<private_encrypted>,
and C<public> attributes are ignored.

=item private

A scalar or SecretBuffer containing a private key or encrypted private key.  The format is
auto-detected.  If the format is encrypted and you do not also specify a password,
this will become the L<private_encrypted> attribute to be decrypted later using
L</decrypt_private>.

=item private_encrypted

If you know that your key is encrypted and can't be decrypted right away, you can specify it as
the C<private_encrypted> attribute to save it for a later L</decrypt_private> without attempting
to C<import> it during the constructor.

=item public

Loading a C<private> key always implies a public key, but if your private key is encrypted this
attribute can be used to provide the public half, enabling the PKey object to be able to encrypt
data even before the private half has been decrypted.

=item password

If the private key is encrypted, this attempts a L</decrypt_private> before the constructor
returns, dying if the password is incorrect.

=back

=cut

our $_ctor_password;
sub new {
   my $class= shift;
   my %attrs= @_ != 1 && ref $_[0] eq 'HASH'? ( %{ $_[0] } ) : @_;
   my $self= bless {}, $class;
   # 'password' is not an attribute, but the ->import methods need access to it.
   # Rather than plumbing that up manually through the constructor and subclasses,
   # just localize a global and then use the methods normally.
   local $_ctor_password= delete $attrs{password}
      if defined $attrs{password};
   $self->_init(\%attrs);
   return $self;
}

# Make sure attributes (or methods) are applied in the following order:
our %_attr_pri= (
   mechanism => -100,
   path => -99,
   private => -5,
   private_encrypted => -4,
   public => -3,
   generate => -1,
   # default = 0
   save => 100,
);
sub _init {
   my ($self, $attrs)= @_;
   # Subclasses may handle specific attributes before calling this.
   # Every remaining attribute must have a writable accessor
   $self->$_($attrs->{$_})
      for sort { ($_attr_pri{$a}||0) <=> ($_attr_pri{$b}||0) } keys %$attrs;
}

=constructor load

  ->load($filename, %options);
  ->load(\$buffer, %options);
  ->load($Crypt_SecretBuffer, %options);
  ->load($Crypt_SecretBuffer_Span, %options);
  ->load($Crypt_SecretBuffer_PEM, %options);

This attempts to parse a variety of key formats and load either a private key, public key, or
encrypted private key.  If the key format is encrypted and the C<%options> do not include
C<'password'>, the encrypted key will be stored in the L</private_encrypted> attribute to be
used by L</decrypt_private> later when the password is available.

If the argument is a L<Crypt::SecretBuffer>, L<Crypt::SecretBuffer::Span>,
L<Crypt::SecretBuffer::PEM>, or scalar-ref, it will be parsed directly.  Anything else is
assumed to be a filename that must be opened/read first.  If given a filename, this also sets
the L</path> attribute.

This can be called as a class constructor or as a method of an existing object to replace the
contents of the object.

=over

=item password

Provide a password to decrypt an encrypted key

=item path

Specify the 'path' attribute for the new object.

=back

=cut

sub load {
   my ($class_or_self, $filename_or_buf, %options)= @_;
   my $self= ref $class_or_self? $class_or_self : bless {}, $class_or_self;
   my $data;
   if (blessed($filename_or_buf) && (
        $filename_or_buf->isa('Crypt::SecretBuffer')
        || $filename_or_buf->isa('Crypt::SecretBuffer::Span')
        || $filename_or_buf->isa('Crypt::SecretBuffer::PEM')
      )
   ) {
      $data= $filename_or_buf;
   }
   elsif (ref $filename_or_buf eq 'SCALAR') {
      $data= span($$filename_or_buf);
   }
   else { # else assume it's a filename
      $data= secret(load_file => $filename_or_buf);
      $options{path}= "$filename_or_buf";
   }
   $self->_import_key($data, %options)
      or croak "Unrecognized key format";
   return $self;
}

sub _looks_like_base64 {
   my $span= span($_[0]);
   return $span->len >= 4 && !$span->scan(qr{[^A-Za-z0-9+/=\r\n\t ]})
}
sub _decode_base64 {
   return span($_[0])->clone(encoding => BASE64)->copy(encoding => ISO8859_1)->span;
}
# ASN.1 DER encoding starts with a type code and then a length and then the contents
# of that type.  The relevant type codes are:
#   0x02 INTEGER
#   0x03 BIT STRING
#   0x04 OCTET STRING
#   0x30 SEQUENCE
# This code looks for the patterns of:
#   SEQUENCE { SEQUENCE {...}, BIT STRING   => RFC 5280 SubjectPublicKeyInfo
#   SEQUENCE { SEQUENCE {...}, OCTET STRING => Encrypted PKCS#8
#   SEQUENCE { INTEGER                      => Unencrypted PKCS#8
sub _identify_asn1 {
   my $span= span($_[0]);
   if ($span->parse("\x30")) {
      my $len= $span->parse_asn1_der_length;
      if ($len && $len <= $span->len) {
         return 'PKCS#8-unencrypted' if $span->starts_with("\x02");
         if ($span->parse("\x30")) { # encrypted PKCS#8, or SubjectPublicKeyInfo
            my $len2= $span->parse_asn1_der_length;
            if ($len2 && $len2 <= $span->len) {
               my $next= $span->subspan($len2);
               return 'SPKI' if $next->starts_with("\x03");
               return 'PKCS#8-encrypted' if $next->starts_with("\x04");
            }
         }
      }
   }
   return '';
}

sub _import_key {
   my ($self, $input, %options)= @_;
   my $is_pem= $input->isa("Crypt::SecretBuffer::PEM");
   delete $self->{fingerprint}; # clear cache
   my $pass= $options{password} // $_ctor_password;
   # Does it look like PEM?
   if ($is_pem || span($input)->scan("-----BEGIN ")) {
      # This could be called on an existing object.  In case a key was already loaded, we need
      # to keep track of whether the routines below succeeded yet.  If so, this method has
      # succeeded, and if not, we need to die while preserving any previous loaded key.
      my $loaded_something= 0;
      # Find all PEM blocks.  There should probably only be one, unless someone added both the
      # public and private PEM to the same file.
      my @pems= $is_pem? ($input) : Crypt::SecretBuffer::PEM->parse_all(span($input))
         or croak "No complete PEM records found";
      for my $pem (@pems) {
         # OpenSSL encrypted key format
         if ($pem->label eq 'ENCRYPTED PRIVATE KEY') {
            if (defined $pass) {
               # password provided, so attempt to import, and die if it fails
               $self->_import_pkcs8($pem->content->copy(encoding => ISO8859_1), $pass);
            } else {
               # password not provided, so save it for later
               $pem->content->copy_to($self->{private_encrypted}= ''); # remains base64
               # this method is now classified as succeeding, so remove any pre-existing key
               # unless the thing loaded was a public key from earlier in the file.
               $self->_clear_key unless $loaded_something;
            }
            $self->_import_pem_headers($pem);
            $loaded_something= 1;
            # unless public key is defined, keep iterating in case the public key was provided
            # as another PEM record in the same file
            return 1 if $self->has_public;
         }
         # OpenSSL unencrypted key format
         elsif ($pem->label eq 'PRIVATE KEY') {
            $self->_import_pkcs8($pem->content->copy(encoding => ISO8859_1));
            $self->_import_pem_headers($pem);
            return 1;
         }
         # OpenSSH key format, which always contains a public key and either an encrypted or
         # unencrypted private key.
         elsif ($pem->label eq 'OPENSSH PRIVATE KEY') {
            # decode base64 to get byte buffer
            my $bytes= $pem->content->copy(encoding => ISO8859_1);
            $self->_import_openssh_privkey($bytes, $pass);
            # loading SSH key may succeed with only public half if the key was encrypted and
            # '$pass' is undef.
            if (!defined $pass && !$self->has_private) {
               $pem->buffer->span->copy_to($self->{private_encrypted}= '');
            }
            return 1;
         }
         elsif ($pem->label eq 'PUBLIC KEY') {
            $self->_import_spki($pem->content->copy(encoding => ISO8859_1));
            $self->_import_pem_headers($pem);
            # keep iterating in case the private key is a second PEM record
            $loaded_something= 1;
         }
      }
      croak "No supported PEM record types were found"
         unless $loaded_something;
      return 1; # either just a public key, or private_encrypted, or both.
   }
   # Does it look like the SSH public key line?
   my $span= span($input);
   if ($span->parse("ssh-") && $span->parse(qr/[-a-z0-9]+/) && $span->parse(" ")
      && ($span=$span->parse(qr{[A-Za-z0-9+/=]+}))
   ) {
      $span->encoding(BASE64);
      $span= $span->copy(encoding => ISO8859_1)->span;
      $self->_import_openssh_pubkey($span);
      return 1;
   }
   $span= span($input);
   again: {
      # Maybe raw bytes of ASN.1?
      my $type;
      if ($span->starts_with("\x30") && ($type= _identify_asn1($span))) {
         if ($type eq 'SPKI') {
            $self->_import_spki($span);
            return 1;
         }
         elsif ($type eq 'PKCS#8-encrypted') {
            if (defined $pass) {
               $self->_import_pkcs8($span, $pass);
            } else {
               $self->_clear_key;
               $self->{private_encrypted}= $span->copy;
            }
            return 1;
         }
         elsif ($type eq 'PKCS#8-unencrypted') {
            $self->_import_pkcs8($span);
            return 1;
         }
      }
      # If the whole thing looks like base64, decode it and try again
      if (_looks_like_base64($span)) {
         $span= _decode_base64($span);
         goto again;
      }
   }
   return 0;
}

sub _import_pem_headers {
   my ($self, $pem)= @_;
   # mechanism header can change the class, then needs re-dispatched
   my $mech= $pem->headers->{cmk_mechanism};
   if ($mech && $mech ne $self->mechanism) {
      $self->mechanism($mech);
      # guard against infinite loop
      $self->mechanism eq $mech or croak "BUG";
      goto $self->can('_import_pem_headers');
   }
   
   # check for a public_key header, which can be paired with encrypted PKCS#8
   unless ($self->has_public) {
      my $pub= $pem->headers->{public_key};
      if (defined $pub && _looks_like_base64($pub)) {
         $self->_import_spki(_decode_base64($pub));
      }
   }
}

=method generate

Replace any current key with a newly generated key of 'type'.  The attribute
private_encrypted is deleted, if present, since it no longer matches the public
key.

Supported types and aliases:

  EC:group=X
  secp256k1   => EC:group=secp256k1
  
  ed25519
  x25519
  
  RSA:bits=N
  RSA         => RSA:bits=4096
  rsa4096     => RSA:bits=4096
  rsa2048     => RSA:bits=2048
  rsa1024     => RSA:bits=1024

=cut

our %type_alias= (
   rsa1024   => 'RSA:bits=1024',
   rsa2048   => 'RSA:bits=2048',
   rsa4096   => 'RSA:bits=4096',
   secp256k1 => 'EC:group=secp256k1',
);
sub generate {
   my ($self, $type)= @_;
   $self= $self->new unless ref $self; # permit usage as a class method
   $type ||= 'x25519';
   $type= $type_alias{lc $type} || $type;
   $self->_keygen($type);
   $self->{type}= $type;
   delete $self->{fingerprint};
   delete $self->{private_encrypted};
   $self;
}

=method export

Export the PKey as a L<SecretBuffer|Crypt::SecretBuffer> object containing OpenSSL PEM text of
PKCS#8 format data, but also with PEM headers that preserve the value of object attributes.
The specific attributes exported depend on the L</mechanism>, but the private half of the key
will never be serialized unencrypted unless L</mechanism> is C<'Unencrypted'>.

  $pkey->export->save_file($filename);

=method export_pem

Export the PKey as a L<Crypt::SecretBuffer::PEM> object.

=method save

  $pkey->save;         # saves to $pkey->path
  $pkey->save($path);  # saves to $path and sets $pkey->path if not already set

This is a shortcut for C<< $pkey->export_pem->serialize->save_file($pkey->path, "rename") >>.

=cut

sub export {
   shift->export_pem->serialize;
}
sub export_pem {
   my ($self)= @_;
   # Serialize as an encrypted private key if and only if the private_encrypted is
   # defined and looks to have been generated by this module (as opposed to some other
   # format passed to the constructor and not yet decrypted)
   if (defined $self->{private_encrypted}) {
      my $content= span($self->{private_encrypted});
      croak "private_encrypted is not in PKCS#8 format (as would be created by ->encrypt_private)"
         unless _looks_like_base64($content)
            && ($content= _decode_base64($content))
            && _identify_asn1($content) eq 'PKCS#8-encrypted';
      return Crypt::SecretBuffer::PEM->new(
         label => 'ENCRYPTED PRIVATE KEY',
         # Store the public key in a PEM header
         header_kv => [ public_key => $self->public ],
         content => $content
      );
   }
   # Export as a public key only
   else {
      $self->_export_spki(my $content);
      return Crypt::SecretBuffer::PEM->new(
         label => 'PUBLIC KEY',
         content => $content
      );
   }
}

sub save {
   my ($self, $path)= @_;
   $path //= $self->path;
   defined $path or croak "No 'path' specified for saving key";
   $self->export->save_file($path, "rename");
   $self->path($path) if !defined $self->path;
}

=method encrypt_private

  $pkey->encrypt_private($password, $kdf_iter=100_000);

Export the (private) key in PKCS#8 format, encrypted with a password, and stored into attribute
C<private_encrypted> to be saved out by a subsequent L</save> call.
You may customize the number of iterations for the key-derivation-function (KDF) to resist
brute-force attempts.  If the password is known to be a string of hashed data with
uniformly-distributed bits, you may reduce the KDF iterations to 1.  (but it cannot be zero,
due to OpenSSL API).
Ideally, C<$password> is a L<SecretBuffer|Crypt::SecretBuffer> object, but scalars are also
accepted.
The password must be bytes, not wide characters, so make sure to encode it first.

=cut

sub encrypt_private {
   my $self= shift;
   defined $_[0] or die "Missing password";
   my $kdf_iter= $_[1] || 100_000;
   my $buf= '';
   $self->_export_pkcs8($buf, $_[0], $kdf_iter);
   $self->{private_encrypted}= encode_base64($buf, '');
   $self;
}

=method clear_private

Delete the private half of the public/private key pair.  You should only call this after
L<encrypting it|/encrypt_private>, or saving it by some other means.

=cut

sub clear_private {
   my $self= shift;
   $self->_export_spki(my $buf);
   $self->_clear_key;
   $self->_import_spki($buf);
   $self;
}

=method decrypt_private

  $pkey->decrypt_private($password);

Using the supplied password, decrypt attribute C<private_encrypted> and import it.
Ideally, C<$password> is a C<SecretBuffer> object, but scalars are also accepted.
The password must be bytes, not wide characters.

=cut

sub decrypt_private {
   my $self= shift;
   defined $_[0] or die "Missing password";
   defined $self->{private_encrypted} or die "Can't decrypt an empty private_encrypted attribute";
   # private_encrypted can either be pure base64 which is pkcs8, or it can be a
   # PEM block that needs format-detection.
   if ($self->{private_encrypted} =~ m|^[A-Za-z0-9+/]+=*\z|) {
#      print "decrypting from base64 PKCS#8\n";
      my $raw= decode_base64($self->{private_encrypted});
      $self->_import_pkcs8($raw, $_[0]);
   } else {
#      print "decrypting from foreign format\n";
      $self->_import_key(span($self->{private_encrypted}), password => $_[0])
         or croak "Unknown key format in private_encrypted";
   }
   $self;
}

=method generate_key_material

  $skey= Crypt::SecretBuffer->new();
  my %tumbler;
  $pkey->generate_key_material(\%tumbler, $skey);

Generate reproducible cryptographic bytes using the public half of this key and append them to
a SecretBuffer.  The parameters needed to reproduce those bytes are stored into a "tumbler".
The key material should then be fed to L<Crypt::MultiKey/hkdf> to derive an AES key.

Calling this method on multiple key objects (with a fresh tumbler hashref for each, but with the
same buffer) allows you to build a compound secret which will then require all of the private
keys to recreate.

=method recreate_key_material

  $skey= Crypt::SecretBuffer->new();
  $key->generate_key_material(\%tumbler, $skey);

Reproduce the cryptographic bytes that were previously generated by L</generate_key_material>
using the private half of this key and the information in C<%tumbler>.

=method encrypt

  $fields= $pkey->encrypt($secret);

Encrypt a secret using the public half of this key.  The secret is ideally a C<SecretBuffer>
object, but may also be a scalar.  The return value is a hashref containing the ciphertext
and other fields that are required to decrypt it, and which depend on the type of key used.

=method decrypt

  $secret_buffer= $pkey->decrypt(\%fields);

Decrypt a secret using the private half of this key.  (and dies if the private half of the key
is not currently available)  The hash of fields must include everything written by C<encrypt>.
The original secret is returned as a L<SecretBuffer object|Crypt::SecretBuffer>.

=cut

1;
